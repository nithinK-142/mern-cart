var b=Object.create;var h=Object.defineProperty;var T=Object.getOwnPropertyDescriptor;var v=Object.getOwnPropertyNames;var M=Object.getPrototypeOf,q=Object.prototype.hasOwnProperty;var A=(r,e,o,s)=>{if(e&&typeof e=="object"||typeof e=="function")for(let t of v(e))!q.call(r,t)&&t!==o&&h(r,t,{get:()=>e[t],enumerable:!(s=T(e,t))||s.enumerable});return r};var i=(r,e,o)=>(o=r!=null?b(M(r)):{},A(e||!r||!r.__esModule?h(o,"default",{value:r,enumerable:!0}):o,r));var w=require("dotenv"),U=i(require("express")),D=i(require("cors")),j=i(require("mongoose"));var I=require("express"),N=i(require("jsonwebtoken")),S=i(require("bcrypt"));var c=require("mongoose"),P=new c.Schema({username:{type:String,required:!0,unique:!0},password:{type:String,required:!0},availableMoney:{type:Number,default:5e3},purchasedItems:[{type:c.Schema.Types.ObjectId,ref:"product",default:[]}]}),n=(0,c.model)("user",P);var p=(0,I.Router)();p.post("/register",async(r,e)=>{let{username:o,password:s}=r.body;try{if(await n.findOne({username:o}))return e.status(400).json({type:"username-already-exists"});let a=await S.default.hash(s,10);await new n({username:o,password:a}).save(),e.json({message:"User Registration Complete!"})}catch(t){e.status(500).json({type:t})}});p.post("/login",async(r,e)=>{let{username:o,password:s}=r.body;try{let t=await n.findOne({username:o});if(!t)return e.status(400).json({type:"no-user-found"});if(!await S.default.compare(s,t.password))return e.status(400).json({type:"wrong-credentials"});let u=N.default.sign({id:t._id},"secret");e.json({token:u,userID:t._id})}catch(t){e.status(500).json({type:t})}});var d=(r,e,o)=>{let s=r.headers.authorization;if(s)N.default.verify(s,"secret",t=>{if(t)return e.sendStatus(403);o()});else return e.sendStatus(401)};p.get("/available-money/:userID",d,async(r,e)=>{let{userID:o}=r.params;try{let s=await n.findById(o);if(!s)return e.status(400).json({type:"no-user-found"});e.json({availableMoney:s.availableMoney})}catch(s){e.status(500).json({type:s})}});var g=require("express");var f=require("mongoose"),L=new f.Schema({productName:{type:String,required:!0},price:{type:Number,required:!0,min:[1,"Prce should be more than 1"]},description:{type:String,required:!0},imageURL:{type:String,required:!0},stockQuantity:{type:Number,required:!0,min:[0,"Stock can't be lower than 0"]}}),m=(0,f.model)("product",L);var y=(0,g.Router)();y.get("/",d,async(r,e)=>{try{let o=await m.find({});e.json({products:o})}catch(o){e.status(400).json({err:o})}});y.post("/checkout",d,async(r,e)=>{let{customerID:o,cartItems:s}=r.body;try{let t=await n.findById(o),a=Object.keys(s),u=await m.find({_id:{$in:a}});if(!t)return e.status(400).json({type:"no-users-found"});if(u.length!==a.length)return e.status(400).json({type:"no-product-found"});let l=0;for(let O in s){let _=u.find(E=>String(E._id)===O);if(!_)return e.status(400).json({type:"no-product-found"});if(_.stockQuantity<s[O])return e.status(400).json({type:"not-enough-stock"});l+=_.price*s[O]}return t.availableMoney<l?e.status(400).json({type:"no-available-money"}):(t.availableMoney-=l,t.purchasedItems.push(...a),await t.save(),await m.updateMany({_id:{$in:a}},{$inc:{stockQuantity:-1}}),e.json({purchasedItems:t.purchasedItems}))}catch(t){return console.error("Server Error:",t),e.status(500).json({error:"Internal Server Error"})}});y.get("/purchased-items/:customerID",d,async(r,e)=>{let{customerID:o}=r.params;try{let s=await n.findById(o);if(!s)return e.status(400).json({type:"no-users-found"});let t=await m.find({_id:{$in:s.purchasedItems}});e.json({purchasedItems:t})}catch(s){e.status(500).json({type:s})}});(0,w.config)();var R=(0,U.default)(),k=process.env.PORT||3001;R.use(U.default.json());R.use((0,D.default)({origin:[`${process.env.URL}`],methods:["POST","GET"],credentials:!0}));R.use("/user",p);R.use("/product",y);var x=async()=>{try{await j.default.connect(`${process.env.MONGODB_URL}`),console.log("MongoDB connected")}catch(r){console.error(`ERROR: ${r}`)}};x();R.listen(k,()=>console.log("SERVER STARTED"));
